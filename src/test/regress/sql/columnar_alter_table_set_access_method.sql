--
-- Testing alter_table_set_access_method
--

-- 1. check conversion of 'normal' tables

CREATE TABLE t (a INT) USING heap;

SELECT COUNT(1) FROM pg_class WHERE relname = 't' AND relam = (SELECT oid FROM pg_am WHERE amname = 'heap');

INSERT INTO t VALUES (1),(2),(3);

SELECT COUNT(*) = 3 FROM t;

SELECT pg_catalog.alter_table_set_access_method('t', 'columnar');

SELECT COUNT(1) FROM pg_class WHERE relname = 't' AND relam = (SELECT oid FROM pg_am WHERE amname = 'columnar');

SELECT COUNT(*)  = 3 FROM t;

DROP TABLE t;

-- 2. check conversion of tables with trigger

CREATE TABLE t (a INT) USING heap;

CREATE or REPLACE FUNCTION trs_before() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  RAISE NOTICE 'BEFORE STATEMENT %', TG_OP;
  RETURN NULL;
END;
$$;

CREATE TRIGGER tr_before_stmt BEFORE INSERT ON t
  FOR EACH STATEMENT EXECUTE PROCEDURE trs_before();

CREATE or REPLACE FUNCTION trs_after() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
  RAISE NOTICE 'AFTER STATEMENT %', TG_OP;
  RETURN NULL;
END;
$$;

CREATE TRIGGER tr_after_stmt AFTER INSERT ON t
  FOR EACH STATEMENT EXECUTE PROCEDURE trs_after();

CREATE or REPLACE FUNCTION trr_before() RETURNS trigger LANGUAGE plpgsql AS $$
BEGIN
   RAISE NOTICE 'BEFORE ROW %: (%)', TG_OP, NEW.a;
   RETURN NEW;
END;
$$;

CREATE TRIGGER tr_before_row BEFORE INSERT ON t
  FOR EACH ROW EXECUTE PROCEDURE trr_before();

create or replace function trr_after() returns trigger language plpgsql as $$
BEGIN
   RAISE NOTICE 'AFTER ROW %: (%)', TG_OP, NEW.a;
   RETURN NEW;
END;
$$;

-- This trigger should not be applied to columnar table
CREATE TRIGGER tr_after_row AFTER INSERT ON t
  FOR EACH ROW EXECUTE PROCEDURE trr_after();

INSERT INTO t VALUES (1);

SELECT COUNT(*) = 4 FROM pg_trigger WHERE tgrelid = 't'::regclass::oid;

SELECT pg_catalog.alter_table_set_access_method('t', 'columnar');

SELECT COUNT(1) FROM pg_class WHERE relname = 't' AND relam = (SELECT oid FROM pg_am WHERE amname = 'columnar');

SELECT COUNT(*) = 3 FROM pg_trigger WHERE tgrelid = 't'::regclass::oid;

INSERT INTO t VALUES (1);


-- 3. check conversion of tables with indexes which can be created with columnar

CREATE TABLE index_table (a INT) USING heap;

CREATE INDEX idx1 ON index_table (a);

-- also create an index with statistics
CREATE INDEX idx2 ON index_table ((a+1));

ALTER INDEX idx2 ALTER COLUMN 1 SET STATISTICS 300;

SELECT COUNT(1) FROM pg_class WHERE relname = 'index_table' AND relam = (SELECT oid FROM pg_am WHERE amname = 'heap');

SELECT indexname FROM pg_indexes WHERE tablename = 'index_table';

SELECT pg_catalog.alter_table_set_access_method('index_table', 'columnar');

SELECT COUNT(1) FROM pg_class WHERE relname = 'index_table' AND relam = (SELECT oid FROM pg_am WHERE amname = 'columnar');

SELECT indexname FROM pg_indexes WHERE tablename = 'index_table';

DROP TABLE index_table;

-- 4. Convert table with indexes and constraints

CREATE TABLE tbl (
  c1 CIRCLE,
  c2 TEXT,
  i int4[],
  p point,
  a int,
  EXCLUDE USING gist
    (c1 WITH &&, (c2::circle) WITH &&)
    WHERE (circle_center(c1) <> '(0,0)'),
  EXCLUDE USING btree
    (a WITH =)
	INCLUDE(p)
	WHERE (c2 < 'astring')
);

CREATE INDEX tbl_gin ON tbl USING gin (i);
CREATE INDEX tbl_gist ON tbl USING gist(p);
CREATE INDEX tbl_brin ON tbl USING brin (a) WITH (pages_per_range = 1);

CREATE INDEX tbl_hash ON tbl USING hash (c2);
ALTER TABLE tbl ADD CONSTRAINT tbl_unique UNIQUE (c2);

CREATE UNIQUE INDEX tbl_btree ON tbl USING btree (a);
ALTER TABLE tbl ADD CONSTRAINT tbl_pkey PRIMARY KEY USING INDEX tbl_btree;

SELECT indexname, indexdef FROM pg_indexes
WHERE tablename = 'tbl'
ORDER BY indexname;

SELECT pg_get_constraintdef(oid) FROM pg_constraint WHERE conrelid = 'tbl'::regclass;

SELECT pg_catalog.alter_table_set_access_method('tbl', 'columnar');

SELECT COUNT(1) FROM pg_class WHERE relname = 'tbl' AND relam = (SELECT oid FROM pg_am WHERE amname = 'columnar');

SELECT indexname FROM pg_indexes WHERE tablename = 'tbl';

SELECT conname FROM pg_constraint
WHERE conrelid = 'tbl'::regclass
ORDER BY conname;

DROP TABLE tbl;

-- 5. check non existing table
SELECT pg_catalog.alter_table_set_access_method('some_test', 'columnar');

-- 6. check if method is different than columnar
CREATE TABLE t(a INT);
SELECT pg_catalog.alter_table_set_access_method('t', 'other');
DROP TABLE t;

-- 7. check if table have identity columns
CREATE TABLE identity_cols_test (a INT, b INT GENERATED BY DEFAULT AS IDENTITY (INCREMENT BY 42));
SELECT pg_catalog.alter_table_set_access_method('identity_cols_test', 'columnar');
DROP TABLE identity_cols_test;
